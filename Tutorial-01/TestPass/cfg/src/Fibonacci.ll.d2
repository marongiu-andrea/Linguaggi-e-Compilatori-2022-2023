Fibonacci: {
  entry: |llvm
    br label %2
  |

  bb1: |llvm
    2:                                                ; preds = %5, %1
    %3 = phi i32 [ 0, %1 ], [ %10, %5 ]
    %4 = phi i32 [ %0, %1 ], [ %7, %5 ]
    ; implementa una "jump table"
    ; di default porta al blocco per il calcolo del prossimo numero di fibonacci
    ; altrimenti porta al blocco finale se incontro le due condizioni finali (0 e 1)
    switch i32 %4, label %5 [
      i32 0, label %11
      i32 1, label %12
    ]
  |

  bb2: |llvm
    5:                                                ; preds = %2
    ; calcola "n - 1" e "n - 2" per la chiamata ricorsiva
    %6 = add nsw i32 %4, -1
    %7 = add nsw i32 %4, -2
    %8 = tail call i32 (i8*, ...) @printf(i8* nonnull dereferenceable(1) getelementptr inbounds ([22 x i8], [22 x i8]* @.str.2, i64 0, i64 0), i32 %4, i32 %6, i32 %7)
    %9 = tail call i32 @Fibonacci(i32 %6)
    %10 = add nsw i32 %9, %3
    br label %2
  |

  bb3: |llvm
    11:                                               ; preds = %2
    br label %12
  |

  bb4: |llvm
    12:                                               ; preds = %2, %11
    %13 = phi i8* [ getelementptr inbounds ([9 x i8], [9 x i8]* @.str, i64 0, i64 0), %11 ], [ getelementptr inbounds ([9 x i8], [9 x i8]* @.str.1, i64 0, i64 0), %2 ]
    %14 = tail call i32 (i8*, ...) @printf(i8* nonnull dereferenceable(1) %13)
    %15 = add nsw i32 %4, %3
    ret i32 %15
  |
  
  # collegamenti
  entry -> bb1: fallthrough
  bb1 -> bb2: default
  bb2 -> bb1: fallthrough
  bb1 -> bb3: value '0'
  bb1 -> bb4: value '1'
  bb3 -> bb4: fallthrough
}
